<!doctype html>
<html>
    <head>
        
        <meta charset="utf-8">
        
        <script src="ace/ace.js" type="text/javascript" data-ace-base="ace" charset="utf-8"></script>
        <script src="../build/ace_grammar.js"></script>
        <script src="grammars/javascript.js"></script>
        
        <style type="text/css">
            body {
                position: relative;
            }

            #editor { 
                margin: 0;
                position: relative;
                width: 100%;
                height: 100%;
                min-width:500px;
                min-height:500px;
            }
        </style>
        
        <title>ACE: Dynamic JavaScript Grammar Demo</title>
    </head>
    <body>
        
        <h3>ACE: Dynamic JavaScript Grammar</h3>

<pre id="editor"></pre>
<textarea id="code" style="display:none">
    // this is part of the AceGrammar code itself
    
    // ACE Tokenizer compatible
    var getLineTokens= function(line, state, row) {
        
        var i, numTokens = this.tokens.length, rewind, token, style, stream, stack, tokens, startBlock = 0;
        
        var ERROR = this.Style.error || "error";
        var DEFAULT = this.LOCALS.DEFAULT;
        
        if ( !state ) state = this.resetState( state );
        state = this.copyState( state );
        stack = state.stack;
        stream = new Stream( line );
        tokens = []; 
        
        if ( !state.inBlock )
        {
            startBlock = 1;
        }
        
        while ( !stream.eol() )
        {
            rewind = false;
            
            if ( stream.eatSpace() ) 
            {
                state.current = null;
                state.currentToken = T_DEFAULT;
                tokens.push( { type: DEFAULT, value: stream.current() } );
                stream.shift();
                continue;
            }
            
            while ( stack.length && !stream.eol() )
            {
                token = stack.pop();
                style = token.tokenize(stream, state, this.LOCALS);
                
                // match failed
                if ( false === style )
                {
                    // error
                    if ( token.ERROR || token.isRequired )
                    {
                        // empty the stack
                        state.stack.length = 0;
                        // skip this character
                        stream.next();
                        // generate error
                        state.current = null;
                        state.currentToken = T_ERROR;
                        tokens.push( { type: ERROR, value: stream.current() } );
                        stream.shift();
                        rewind = true;
                        break;
                    }
                    // optional
                    else
                    {
                        continue;
                    }
                }
                // found token
                else
                {
                    state.current = token.tokenName;
                    tokens.push( { type: style, value: stream.current() } );
                    stream.shift();
                    rewind = true;
                    break;
                }
            }
            
            if ( rewind ) continue;
            
            if ( !stream.eol() )
            {
                for (i=0; i<numTokens; i++)
                {
                    token = this.tokens[i];
                    style = token.tokenize(stream, state, this.LOCALS);
                    
                    // match failed
                    if ( false === style )
                    {
                        // error
                        if ( token.ERROR || token.isRequired )
                        {
                            // empty the stack
                            state.stack.length = 0;
                            // skip this character
                            stream.next();
                            // generate error
                            state.current = null;
                            state.currentToken = T_ERROR;
                            tokens.push( { type: ERROR, value: stream.current() } );
                            stream.shift();
                            rewind = true;
                            break;
                        }
                        // optional
                        else
                        {
                            continue;
                        }
                    }
                    // found token
                    else
                    {
                        state.current = token.tokenName;
                        tokens.push( { type: style, value: stream.current() } );
                        stream.shift();
                        rewind = true;
                        break;
                    }
                }
            }
            
            if ( rewind ) continue;
            
            if ( !stream.eol() )
            {
                // unknown, bypass
                stream.skipToEnd();
                state.current = null;
                state.currentToken = T_DEFAULT;
                tokens.push( { type: DEFAULT, value: stream.current() } );
                stream.shift();
            }
        }
        
        if ( startBlock && state.inBlock )
        {
            state.startBlock = 1;
        }
        else
        {
            state.startBlock = 0;
        }
        
        //console.log(tokens);
        //console.log(state);
        
        // ACE Tokenizer compatible
        return { state: state, tokens: tokens };
    }
}
</textarea>
        <p></p>

        <script>
        // <![CDATA[
        
        // 2. parse the grammar into an ACE syntax-highlight mode
        var js_mode = AceGrammar.getMode( js_grammar );
        
        // 3. use it with ACE
        var editor = ace.edit("editor");
        editor.setValue(document.getElementById("code").value);
        editor.getSession().setMode( js_mode );
        
        // ]]>
        </script>
    </body>
</html>
